/***************************************************************\
 *     The skeleton of this class is generated by an automatic *
 * code generator for NC product.                              *
 \***************************************************************/

package nc.bs.fbs.pub;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;

import nc.bs.ml.NCLangResOnserver;
import nc.bs.pub.DataManageObject;
import nc.bs.pub.SystemException;
import nc.jdbc.framework.crossdb.CrossDBConnection;
import nc.jdbc.framework.util.DBConsts;
import nc.vo.pub.BusinessException;

/**
 * 
 * 
 * 封装有关临时表的公共方法 建表、批插数据，删除临时表数据
 * 
 * 所有业务模块都从这里引用临时表。
 * 
 * 考虑到执行效率和存储效率，调用者 自己保证传入数据的唯一性。
 * 
 * 创建日期：(2004-4-16) 作者：hanwei
 */
public class TempTableDMO extends DataManageObject {
	/**
	 * BillRowNoDMO 构造子注解。
	 * 
	 * @exception javax.naming.NamingException
	 *                父类构造子抛出的异常。
	 * @exception nc.bs.pub.SystemException
	 *                父类构造子抛出的异常。
	 */
	public TempTableDMO() throws javax.naming.NamingException, SystemException {
		super();
	}

	/**
	 * BillRowNoDMO 构造子注解。
	 * 
	 * @param dbName
	 *            java.lang.String 在EJB Server中配置的数据库DataSource名称。
	 * @exception javax.naming.NamingException
	 *                父类构造子抛出的异常。
	 * @exception nc.bs.pub.SystemException
	 *                父类构造子抛出的异常。
	 */
	public TempTableDMO(String dbName) throws javax.naming.NamingException,
			SystemException {
		super(dbName);
	}

	//nc.bs.scm.pub.TempTableDMO.insertTempTable(ArrayList, String, String)
	//当insertTempTable 参数 alIDs长度小于等于MINNUM时候，采用in('','')的方式

	/**
	 * 100条只是个经验值,这个数字如何确定呢,我们首先考虑这个数是小于999的,不然oracle自己就报错了 其次我们考虑a.pk_invmandoc
	 * in ( select id from t_ia_bill_inv)这个语句中a表上的建立在pk_invmandoc字段上的
	 * 索引的唯一程度有多高,本例中是2009,那么我们的值不能超过2009*7% ,也就是140 , 所以我们定了100这个值,
	 * 在大多数情况下,我们放到50-100就可以了
	 */
	private int MINNUM = 100; //2004-10-08:根据祝奇的建议修改为100。

	/**
	 * 方法说明：通过传入多个字段名称，字段类型数组，索引列字符，字段数据 可以创建多个字段的临时表并负责插入数据 返回：临时表名称 参数： String
	 * TabName：表名称 String[] TabColumns ：表字段名称列 String[] typenames：表字段类型列 String
	 * IndColumn：表字段索引列 ArrayList alValue：表字段值列 1～n 的元素为 ArrayList表示数据库对应的1～n条记录
	 * 每个子ArrayList表示数据库对应的1条记录数据，其内部的数据元素为按表字段顺序排列的数据
	 */

	public String getTempStringTable(String TabName, String[] TabColumns,
			String[] typenames, String IndColumn, ArrayList<ArrayList<String>> alValue)
			throws Exception {
		CrossDBConnection con = null;
		con = (CrossDBConnection) getConnection();
		return getTempStringTable(con, TabName, TabColumns, typenames,
				IndColumn, alValue);
	}

	/**
	 * 方法说明：通过传入多个字段名称，字段类型数组，索引列字符，字段数据 可以创建多个字段的临时表并负责插入数据 返回：临时表名称 参数： String
	 * TabName：表名称 String[] TabColumns ：表字段名称列 String[] typenames：表字段类型列 String
	 * IndColumn：表字段索引列 String sSql 为对应TabColumns的子查询SQL语句，
	 * 查询字段的内容和顺序要与TabColumns保持一致。
	 */
	public String getTempStringTable(Connection con, String sTabNames,
			String[] sTabColumns, String[] sTypenames, String[] sIndColumns,
			String sSql) throws Exception {

		if (sTabNames == null || con == null || sTabColumns == null
				|| sTabColumns.length == 0 || sTypenames == null
				|| sTypenames.length == 0
				|| sTabColumns.length != sTypenames.length || sSql == null
				|| sSql.length() == 0) {

			return null;
		}

		PreparedStatement stmt = null;
		String sResultTemp = null;
		try {
			//创建临时表
			sResultTemp = createTempTable(con, sTabNames, sTabColumns,
					sTypenames, sIndColumns, -1);//不可知的统计信息

			StringBuffer sTabColumn = new StringBuffer("");

			for (int i = 0; i < sTabColumns.length; i++) {
				if (i > 0)
					sTabColumn.append(",");

				sTabColumn.append(sTabColumns[i]).append(" ");
			}

			//插入子查询
			insertIDs(sSql, sResultTemp, sTabColumn.toString(),
					(CrossDBConnection) con);
		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}

		}
		return sResultTemp;
	}

	/**
	 * 
	 * 功能描述:查询指定SQL的执行结果行数。
	 * 
	 * 输入参数:a valid sql
	 * 
	 * 返回值: 行数.>=0 异常处理: 日期:
	 */
	private int querySqlResultCount(String sSql) {
		int iCount = 2000;
		if (sSql == null || sSql.trim().length() == 0)
			return iCount;
		Connection con = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		try {
			con = getConnection();
			stmt = con.prepareStatement("SELECT COUNT(*) FROM (" + sSql
					+ ") T ");

			rs = stmt.executeQuery();

			if (rs.next()) {
				iCount = new Integer(rs.getObject(1).toString()).intValue();
			}
		} catch (Exception e) {
			/** <needn't:just try code > */
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}
			try {
				if (con != null) {
					con.close();
				}
			} catch (Exception e) {
			}
		}
		return iCount;
	}

	/**
	 * 
	 * 2005-06-17，wnj 方法说明：
	 * 
	 * 通过传入多个字段名称，字段类型数组，索引列字符，字段数据 可以创建多个字段的临时表并负责插入数据
	 * 
	 * 为了保证得到好的执行计划，先执行一次查询以确定表中的行数。
	 * 
	 * 返回：临时表名称 参数： String TabName：表名称 String[] TabColumns ：表字段名称列 String[]
	 * typenames：表字段类型列 String IndColumn：表字段索引列 String sSql
	 * 为对应TabColumns的子查询SQL语句，
	 * 
	 * iRowCount ：传入的SQL执行结果行数，传入 <=0则表示未知的行数，方法里面会先查询一次行数。
	 * 
	 * 
	 * 查询字段的内容和顺序要与TabColumns保持一致。
	 * 
	 *  
	 */
	public String getTempTableNameWithRowStatBySql(Connection con,
			String sTabNames, String[] sTabColumns, String[] sTypenames,
			String[] sIndColumns, String sSql, int iRowCount) throws Exception {

		if (sTabNames == null
		//|| con == null
				|| sTabColumns == null || sTabColumns.length == 0
				|| sTypenames == null || sTypenames.length == 0
				|| sTabColumns.length != sTypenames.length || sSql == null
				|| sSql.length() == 0) {
			return null;
		}
		//2005-06-17，WNJ，没有传入连接则使用缺省的当前连接。会不会有问题？
		if (con == null)
			con = getConnection();
		PreparedStatement stmt = null;
		String sResultTemp = null;
		try {
			//2005-06-17，WNJ，先试探一下行数.
			int iResultCount = iRowCount;
			if (iRowCount <= 0)
				iResultCount = querySqlResultCount(sSql);
			//创建临时表
			sResultTemp = createTempTable(con, sTabNames, sTabColumns,
					sTypenames, sIndColumns, iResultCount);

			StringBuffer sTabColumn = new StringBuffer("");

			for (int i = 0; i < sTabColumns.length; i++) {
				if (i > 0)
					sTabColumn.append(",");

				sTabColumn.append(sTabColumns[i]).append(" ");
			}

			//插入子查询
			insertIDs(sSql, sResultTemp, sTabColumn.toString(),
					(CrossDBConnection) con);
		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}

		}
		return sResultTemp;
	}

	/**
	 * 方法说明：通过传入多个字段名称，字段类型数组，索引列字符，字段数据 可以创建多个字段的临时表并负责插入数据 返回：临时表名称 参数： String
	 * TabName：表名称 String[] TabColumns ：表字段名称列 String[] typenames：表字段类型列 String
	 * IndColumn：表字段索引列 ArrayList alValue：表字段值列
	 *  
	 */
	public String getTempStringTable(Connection con, String TabName,
			String[] TabColumns, String[] typenames, String IndColumn,
			ArrayList<ArrayList<String>> alValue) throws Exception {

		if (TabName == null || con == null || TabColumns == null
				|| TabColumns.length == 0 || typenames == null
				|| typenames.length == 0
				|| TabColumns.length != typenames.length)
			return null;

		StringBuffer sTabColumn = new StringBuffer(TabColumns[0] + " "
				+ typenames[0]);

		for (int i = 1; i < TabColumns.length; i++) {
			sTabColumn.append(",").append(TabColumns[i]).append(" ").append(
					typenames[i]);

		}
		//HashMap hmUnique = new HashMap(); //唯一性校验。不支持。
		String sTempTable = null;
		PreparedStatement stmt = null;
		try {
			sTempTable = createTempTable(con, TabName, sTabColumn.toString()
					+ ",ts char(19)", IndColumn, (alValue == null ? -1
					: alValue.size()));
			if (sTempTable == null)
				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000055")/*
																  * @res
																  * "创建临时表错误！"
																  */
						+ TabName);
			if (alValue != null && alValue.size() > 0) {
				StringBuffer sql1 = new StringBuffer("insert into "
						+ sTempTable + " (").append(TabColumns[0]);

				StringBuffer sql2 = new StringBuffer(" values (?");

				for (int i = 1; i < TabColumns.length; i++) {
					sql1.append(",").append(TabColumns[i]);
					sql2.append(",?");
				}
				sql1.append(")");
				sql2.append(")");
				String sql = sql1 + " " + sql2;

				stmt = prepareStatement(con, sql);

				for (int i = 0; i < alValue.size(); i++) {
					ArrayList<String> alrow = (ArrayList<String>) alValue.get(i);
					if (alrow == null)
						continue;
					for (int j = 0; j < TabColumns.length; j++) {
						if ("int".equalsIgnoreCase(typenames[j])
								|| "smallint".equalsIgnoreCase(typenames[j])) {
							if (alrow.get(j) != null
                  && alrow.get(j).toString().trim().length()>0) {
								stmt.setInt(j + 1, Integer.parseInt(alrow
										.get(j).toString()));
							} else {
								stmt.setNull(j + 1, Types.INTEGER);
							}
						} else //2005-03-17 wnj support decimal type.
						if (typenames[j] != null
								&& (typenames[j].toLowerCase().startsWith(
										"decimal") || typenames[j]
										.toLowerCase().startsWith("number"))) {
							if (alrow.get(j) != null
                  &&alrow.get(j).toString().trim().length()>0) {
								stmt.setBigDecimal(j + 1, new BigDecimal(alrow
										.get(j).toString()));
							} else {
								stmt.setNull(j + 1, Types.DECIMAL);
							}
						} else {
							if (alrow.get(j) != null) {
								stmt.setString(j + 1, (String) alrow.get(j));
							} else {
								stmt.setNull(j + 1, Types.CHAR);
							}
						}
					}
					executeUpdate(stmt);

				}
				executeBatch(stmt);

			}

		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}

		}
		return sTempTable;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 saID：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(String[] saID, String sTemTableName,
			String sPKFieldName) throws Exception {

		return getTempTable(saID, sTemTableName, sPKFieldName, " char(20) ");
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 saID：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * sFieldType:字段类型
	 * 
	 * 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(String[] saID, String sTemTableName,
			String sPKFieldName, String sFieldType) throws Exception {
		if (saID == null || saID.length == 0 || sTemTableName == null
				|| sPKFieldName == null) {
			return null;
		}

		CrossDBConnection con = null;
		String sTemTableNameResult = null;

		try {
			con = (CrossDBConnection) getConnection();
			con.enableSQLTranslator(false);
			sTemTableNameResult = createTempTable(con, sTemTableName,
					sPKFieldName + " " + sFieldType + ",ts char(20)",
					sPKFieldName, (saID == null ? -1 : saID.length));

			if (sTemTableNameResult == null) {

				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000055")/*
																  * @res
																  * "建立临时表出错误，请联系系统管理员。"
																  */);

			}
			boolean bResult = insertIDs(saID, sTemTableNameResult,
					sPKFieldName, con);

			if (!bResult) {
				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000057")/*
																  * @res
																  * "插入临时表出错误，请联系系统管理员。"
																  */);
			}

		} finally {
			try {
				if (con != null) {
					con.enableSQLTranslator(true);
					con.close();
				}
			} catch (Exception e) {

			}
		}

		return sTemTableNameResult;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 sQryIdSql：ID字段查询语句 select id from ddd .....
	 * 注意只能有一个id字段的查询 sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(String sQryIdSql, String sTemTableName,
			String sPKFieldName) throws Exception {

		return getTempTable(sQryIdSql, sTemTableName, sPKFieldName,
				" char(20) ");
	}
	
	/**
	 * 追加临时表数据。 插入临时表方案 sQryIdSql：ID字段查询语句 select id from ddd .....
	 * 注意只能有一个id字段的查询 sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public void appendTempTable(String sQryIdSql, String sTemTableName,String sPKFieldName) throws Exception {
		
		insertIDs(sQryIdSql,sTemTableName,sPKFieldName,(CrossDBConnection)getConnection());
		return ;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 sQryIdSql：ID字段查询语句 select id from ddd .....
	 * 注意只能有一个id字段的查询 sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(String sQryIdSql, String sTemTableName,
			String sPKFieldName, String sFieldType) throws Exception {
		CrossDBConnection con = null;
		String sTemTableNameResult = null;
		try {
			con = (CrossDBConnection) getConnection();
			con.enableSQLTranslator(false);
			sTemTableNameResult = createTempTable(con, sTemTableName,
					sPKFieldName + " " + sFieldType + " ,ts char(20)",
					sPKFieldName, -1);//未知统计信息。

			if (sTemTableNameResult == null) {
				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000055")/*
																  * @res
																  * "建立临时表出错误，请联系系统管理员。"
																  */);
			}
			boolean bResult = insertIDs(sQryIdSql, sTemTableNameResult,
					sPKFieldName, con);

			if (!bResult) {
				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000057")/*
																  * @res
																  * "插入临时表出错误，请联系系统管理员。"
																  */);

			}

		} catch (Exception e) {
			throw e;
		} finally {
			try {
				if (con != null) {
					con.enableSQLTranslator(true);
					con.close();
				}
			} catch (Exception e) {

			}
		}

		return sTemTableNameResult;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 alIDs：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(ArrayList<String> alIDs, String sTemTableName,
			String sPKFieldName) throws Exception {

		String sResultTempTable = null;
		String[] saID = new String[alIDs.size()];
		alIDs.toArray(saID);
		sResultTempTable = getTempTable(saID, sTemTableName, sPKFieldName);
		return sResultTempTable;
	}

	/**
	 * 创建者：韩卫 功能：批执行插入单个字段，多个数据 只执行一次prepareStatement,多次调用execute() String[]
	 * sIDs：多个ID数据 String sTable：表名称 String sFieldName：字段名称
	 * nc.bs.mw.sql.UFConnection con：连接 参数： 返回： 例外： 日期：(2004-3-27 9:07:50)
	 * 修改日期，修改人，修改原因，注释标志： 2003-11-06 hanwei 日期
	 */

	private boolean insertIDs(String[] sIDs, String sTable, String sFieldName,
			CrossDBConnection con) throws Exception {

		if (sIDs == null || con == null || sTable == null || sFieldName == null) {
			return false;
		}
		String sql = "insert into " + sTable + " (" + sFieldName
				+ ") values(?)";

		con.enableSQLTranslator(false);
		PreparedStatement stmt = null;
		try {
			stmt = prepareStatement(con, sql);
			//Vector v = new Vector();
			HashMap<String,String> hmUnique = new HashMap<String,String>(); //唯一性校验，用VECTOR检索效率太低。2004-10-08王乃军改为hashmap.

			for (int i = 0; i < sIDs.length; i++) {
				if (sIDs[i] == null || hmUnique.containsKey(sIDs[i]))
					continue;
				stmt.setString(1, sIDs[i]);
				executeUpdate(stmt);
				hmUnique.put(sIDs[i], "");
				//v.add(sIDs[i]);
			}
			executeBatch(stmt);

		} finally {
			try {
				stmt.close();
			} catch (Exception e) {
			}

		}
		return true;
	}

	/**
	 * 创建者：韩卫 功能：批执行插入单个字段，多个数据 只执行一次prepareStatement,多次调用execute()
	 * sQryIdSql：查询ID数据的子查询 String sTable：表名称 String sFieldName：字段名称
	 * nc.bs.mw.sql.UFConnection con：连接 参数： 返回： 例外： 日期：(2004-3-27 9:07:50)
	 * 修改日期，修改人，修改原因，注释标志： 2003-11-06 hanwei 日期
	 */

	private boolean insertIDs(String sQryIdSql, String sTable,
			String sFieldName, CrossDBConnection con) throws Exception {

		if (sQryIdSql == null) {
			return false;
		}
		String sql = "insert into " + sTable + " (" + sFieldName + ")  ( "
				+ sQryIdSql + " )";

		con.enableSQLTranslator(true);
		PreparedStatement stmt = null;
		try {
			stmt = con.prepareStatement(sql);
			stmt.execute();

		} finally {
			try {
				stmt.close();
			} catch (Exception e) {
			}

		}
		return true;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 saID：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (1) (select id from temptable) (2) ('','','')
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(String[] saID, String sTemTableName,
			String sPKFieldName) throws Exception {

		return insertTempTable(saID, sTemTableName, sPKFieldName, " char(20) ");
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 saID：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (1) (select id from temptable) (2) ('','','')
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(String[] saID, String sTemTableName,
			String sPKFieldName, String sFieldType) throws Exception {
		if (saID == null || saID.length == 0 || sTemTableName == null
				|| sPKFieldName == null) {
			return STRNULL;
		}
		String sResultSql = null;
		String sTemTableNameResult = null;
		//HashMap hmUnique = new HashMap(); //唯一性校验。不支持。
		if (saID.length <= MINNUM) {
			String sID = null;
			StringBuffer sbSql = new StringBuffer("(");
			for (int i = 0; i < saID.length; i++) {
				if (i > 0) {
					sbSql.append(",");
				}
				sbSql.append("'");
				sID = saID[i];
				if (sID == null) {
					sID = "";
				}
				sbSql.append(sID);
				sbSql.append("'");
			}
			sbSql = sbSql.append(")");
			sResultSql = sbSql.toString();
		} else {
			sTemTableNameResult = getTempTable(saID, sTemTableName,
					sPKFieldName, sFieldType);
			if (sTemTableNameResult == null)
				sResultSql = STRNULL;
			else
				sResultSql = " ( select " + sPKFieldName + " from  "
						+ sTemTableNameResult + ")";
		}

		return sResultSql;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 sQryIdSql：ID字段查询语句 select id from ddd .....
	 * 注意只能有一个id字段的查询 sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (select id from temptable)
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(String sQryIdSql, String sTemTableName,
			String sPKFieldName) throws Exception {

		return insertTempTable(sQryIdSql, sTemTableName, sPKFieldName,
				" char(20) ");
	}
	/**
	 * 返回临时表名称(允许指定临时表ID列宽度)
	 * @param sQryIdSql
	 * @param sTemTableName
	 * @param sPKFieldName
	 * @param iWidth
	 * @return
	 * @throws Exception
	 * @author czp
	 * @date 2006-11-04
	 */
	public String insertTempTableWhitColWidth(String sQryIdSql, String sTemTableName,
			String sPKFieldName, int iWidth) throws Exception{		
		return insertTempTable(sQryIdSql, sTemTableName, sPKFieldName," varchar("+ iWidth +") ");
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 sQryIdSql：ID字段查询语句 select id from ddd .....
	 * 注意只能有一个id字段的查询 sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (select id from temptable)
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(String sQryIdSql, String sTemTableName,
			String sPKFieldName, String sFieldType) throws Exception {
		String sResultSql = null;
		String sTemTableNameResult = null;
		sTemTableNameResult = getTempTable(sQryIdSql, sTemTableName,
				sPKFieldName, sFieldType);
		if (sTemTableNameResult == null)
			sResultSql = STRNULL;
		else
			sResultSql = " ( select " + sPKFieldName + " from  "
					+ sTemTableNameResult + ")";

		return sResultSql;
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 alIDs：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (1) (select id from temptable) (2) ('','','')
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(ArrayList<String> alIDs, String sTemTableName,
			String sPKFieldName) throws Exception {

		return insertTempTable(alIDs, sTemTableName, sPKFieldName, " char(20) ");
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 alIDs：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 (1) (select id from temptable) (2) ('','','')
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String insertTempTable(ArrayList<String> alIDs, String sTemTableName,
			String sPKFieldName, String sFieldType) throws Exception {

		String sResultSql = null;
		String[] saID = new String[alIDs.size()];
		alIDs.toArray(saID);
		sResultSql = insertTempTable(saID, sTemTableName, sPKFieldName,
				sFieldType);
		return sResultSql;
	}

	//前一次调用createTempTable（）产生的临时表。用于插入数据后的统计信息写入。
	//INSERT INTO SELECT 的方式不支持统计信息。
	//private nc.bs.mw.sqltrans.TempTable m_TempTable = null;
	//为空情况不能直接返回(''),在Oracle情况下会做null处理导致错误
	private String STRNULL = "('#@')";

	/**
	 * 方法说明：通过传入多个字段名称，字段类型数组，索引列字符，字段数据 可以创建多个字段的临时表并负责插入数据 返回：临时表名称 参数： String
	 * TabName：表名称 String[] TabColumns ：表字段名称列 String[] typenames：表字段类型列 String
	 * IndColumn：表字段索引列 String[][] sValues 值
	 */
	public String getTempStringTable(String TabName, String[] TabColumns,
			String[] typenames, String IndColumn, String[][] sValues)
			throws Exception {
		ArrayList<ArrayList<String>> alValue = new ArrayList<ArrayList<String>>();

		for (int i = 0; i < sValues.length; i++) {
			ArrayList<String> altemp = new ArrayList<String>();
			for (int j = 0; j < sValues[i].length; j++) {
				altemp.add(sValues[i][j]);
			}

			alValue.add(altemp);
		}

		return getTempStringTable(TabName, TabColumns, typenames, IndColumn,
				alValue);
	}

	/**
	 * 此处插入方法说明。 插入临时表方案 alIDs：ID字段ArrayList sTemTableName：表名 sPKFieldName：字段名
	 * 
	 * 返回 返回 临时表名称
	 * 
	 * 创建日期：(2004-3-25 17:36:13)
	 * 
	 * @return java.lang.String
	 */
	public String getTempTable(ArrayList<String> alIDs, String sTemTableName,
			String sPKFieldName, String sPKFildType) throws Exception {

		String sResultTempTable = null;
		String[] saID = new String[alIDs.size()];
		alIDs.toArray(saID);
		sResultTempTable = getTempTable(saID, sTemTableName, sPKFieldName,
				sPKFildType);
		return sResultTempTable;
	}

	private int DEFAULT_STAT = 200; //统计信息缺省值,2004-12-09:根据祝奇的建议修改为200。

	/**
	 * 创建者：韩卫 功能：创建临时表封装的方法 String TabName：表名称 String[] TabColumns ：表字段名称列数组
	 * String[] typenames：表字段类型列数组 String[] IndColumn：表字段索引列数组 参数： 返回： 例外：
	 * 日期：(2004-3-27 9:07:50) 修改日期，修改人，修改原因，注释标志：
	 */

	private String createTempTable(Connection con, String TabName,
			String[] TabColumns, String[] typenames, String[] IndColumns,
			int iRowCount) throws BusinessException {

		if (TabName == null || con == null || TabColumns == null
				|| TabColumns.length == 0 || typenames == null
				|| typenames.length == 0
				|| TabColumns.length != typenames.length)
			return null;

		StringBuffer sTabColumn = new StringBuffer(TabColumns[0] + " "
				+ typenames[0]);
		for (int i = 1; i < TabColumns.length; i++) {
			sTabColumn.append(",").append(TabColumns[i]).append(" ").append(
					typenames[i]);

		}
		StringBuffer sbIndColumn = new StringBuffer("");
		;
		if (IndColumns != null)
			for (int i = 0; i < IndColumns.length; i++) {
				if (i > 0)
					sbIndColumn.append(",");

				sbIndColumn.append(IndColumns[i]).append(" ");

			}
		String IndColumn = null;
		if (sbIndColumn != null && sbIndColumn.toString().length() > 0)
			IndColumn = sbIndColumn.toString();

		String sTempTable = null;
		PreparedStatement stmt = null;
		try {
			sTempTable = createTempTable(con, TabName, sTabColumn.toString()
					+ ",ts char(19)", IndColumn, iRowCount);
			if (sTempTable == null)
				throw new BusinessException(NCLangResOnserver.getInstance()
						.getStrByID("scmpub", "UPPscmpub-000055")/*
																  * @res
																  * "创建临时表错误！"
																  */
						+ TabName);

		} catch (Exception e) {
			throw new BusinessException(e.getMessage());
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}

		}
		return sTempTable;
	}

	/**
	 * 创建者：韩卫 功能：创建临时表封装的方法 String TabName：表名称 String[] TabColumns ：表字段名称列数组
	 * String[] typenames：表字段类型列数组 String[] IndColumn：表字段索引列数组 参数： 返回： 例外：
	 * 日期：(2004-3-27 9:07:50) 修改日期，修改人，修改原因，注释标志：
	 * 2004-10-08，王乃军，支持统计信息，加入了m_sTempTableName属性。
	 */
	private String createTempTable(Connection con, String TabName,
			String TabColumn, String IndColumn, int iRowCount)
			throws SQLException {

		if (TabName == null || TabColumn == null || con == null)
			return null;

		Statement stmt = con.createStatement();
		String tabname = null;
		try {
			//创建表
			nc.bs.mw.sqltrans.TempTable tt = new nc.bs.mw.sqltrans.TempTable();
			if (iRowCount > 0) //设置统计信息。
				tt.setRowsnum(iRowCount);
			else {
				tt.setRowsnum(DEFAULT_STAT);
			}

			tabname = tt.createTempTable(con, TabName, TabColumn, IndColumn);
			//nc.vo.scm.pub.SCMEnv.out("create tt ok:"+TabName);
			return tabname;
		} finally {
			try {
				if (stmt != null) {
					stmt.close();
				}
			} catch (Exception e) {
			}

		}

	}
	
	
	/**
	 * 创建者：ydy
	 * 功能：获取真实的临时表表名，不同数据库会返回不同的名称；
	 * 该方法不负责创建临时表
	 * 
	 * 修改--zc,lky v5.6 DB29.7以后创建临时表都没有前缀session.
	 */	
	public  String getRealTableName(String sTableName){
		
		try{
			
			int type=getDatabaseType();
			if(type==DBConsts.SQLSERVER)
				return "#"+sTableName;
			else if(type==DBConsts.DB2){
//	2009-12-22 fengjb lky hgy 由于何冠宇回退临时表补丁，直接改成下面形式即可
//				//修改--zc,lky v5.6 DB29.7以后创建临时表都没有前缀session.
//				int majorv = getConnection().getMetaData().getDatabaseMajorVersion();
//				int minorv = getConnection().getMetaData().getDatabaseMinorVersion();
//				if (majorv >= 9 && minorv >= 7)
//					return sTableName;
//				else
					return "session."+sTableName;
			}
			else 
				return sTableName;
			
			}catch (Exception e){
			
			return sTableName;
			
		}
		
		
		
	}

  /**
   * @return mINNUM
   */
  public int getMINNUM() {
    return MINNUM;
  }

  /**
   * @param minnum 要设置的 mINNUM
   */
  public void setMINNUM(int minnum) {
    MINNUM = minnum;
  }
}